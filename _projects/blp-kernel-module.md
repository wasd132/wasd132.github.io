---
layout: project
title: "접근통제 정책 집행을 위한 리눅스 커널 모듈 개발"
summary: "Bell-LaPadula(BLP) 모델을 시스템 콜 후킹 기반으로 구현한 강제 접근통제(MAC) 커널 모듈입니다. 'No Read Up, No Write Down' 정책을 커널 레벨에서 강제하여 방산기업 등 민감한 정보를 다루는 환경에서 내부자 위협을 차단합니다. 4단계 보안 등급(Unclassified ~ Top Secret)을 시스템 콜 레벨에서 검증합니다."
image: assets/images/s3scan.png
technologies: [C, Linux Kernel, System Call Hooking, BLP Model]
github:
categories: security
---

## 프로젝트 배경

민간 방산기업과 같이 국가 중요시설로 지정된 조직에서는 DAC(Discretionary Access Control)만으로 기밀 정보를 보호하기 어렵습니다. 내부자가 권한을 남용하거나 산업 스파이가 침투할 경우, 중요 설계도나 기밀 문서가 유출될 위험이 있습니다.

Bell-LaPadula(BLP) 모델은 **"No Read Up(상위 등급 읽기 금지), No Write Down(하위 등급 쓰기 금지)"** 원칙으로 기밀성을 보장하는 대표적인 MAC(Mandatory Access Control) 모델입니다. 이를 리눅스 커널의 시스템 콜 후킹 기반으로 구현하여, 사용자가 파일 접근 시도 시 커널 레벨에서 보안 등급을 강제 검증하도록 했습니다.

## 주요 기능

### 1. 시스템 콜 후킹 기반 BLP 정책 강제
`sys_openat`, `read`, `write` 시스템 콜을 커널 레벨에서 후킹하여, 파일 접근 시도마다 사용자(주체)와 파일(객체)의 보안 등급을 비교합니다. BLP 정책 위반 시 시스템 콜을 차단하고 시스템 로그에 기록합니다.

### 2. 4단계 보안 등급 체계
방산기업의 기밀성 요구사항에 맞춰 다음의 보안 등급을 정의합니다:
- **Level 0 (Unclassified)**: 공개 정보
- **Level 1 (Confidential)**: 사내 기밀
- **Level 2 (Secret)**: 중요 기밀 (장비 설계도 등)
- **Level 3 (Top Secret)**: 최고 기밀

### 3. "No Read Up" 정책 구현
낮은 보안 등급의 사용자가 높은 보안 등급의 파일을 `open()` 또는 `read()` 시도 시, 커널 모듈이 이를 차단합니다. 실제 `vfs_read()` 함수를 호출하지 않고 사용자 공간 버퍼를 `\x00`으로 채워 읽기를 차단하면서도 시스템 안정성을 유지합니다.

### 4. "No Write Down" 정책 구현
높은 보안 등급의 사용자가 낮은 보안 등급의 파일에 쓰기 시도 시, `open()` 함수에서 write 권한(`O_WRONLY`, `O_RDWR`) 포함 여부를 확인하여 파일 디스크립터(fd) 자체를 열지 못하게 차단합니다. 이를 통해 기밀 정보가 낮은 등급 파일로 유출되는 것을 방지합니다.

### 5. 시스템 로그 기반 감사
`read()` 시스템 콜 실패 등 보안 정책 위반 시도를 모두 커널 로그(`/var/log/kern.log`)에 기록하여 침해사고 분석과 내부자 위협 추적을 지원합니다.

## BLP 모델 동작 원리

BLP 모델의 2대 핵심 속성을 시스템 콜 후킹으로 구현합니다:

### 1. No Read Up (Simple Security Property)
**낮은 보안 등급의 사용자가 높은 보안 등급의 데이터를 읽을 수 없도록 합니다.**

- **정책**: 사용자는 자신의 보안 등급보다 높은 등급의 파일을 읽을 수 없음
- **예시**: Level 1(Confidential) 엔지니어가 Level 2(Secret) 장비 설계도 파일을 `cat` 시도 → 차단
- **구현 방식**: 
  1. `sys_openat` 후킹으로 파일 열기 시도 감지
  2. 사용자 UID와 파일 보안 등급 비교
  3. `subject_level < object_level` 조건 위반 시 `-EACCES` 반환
  4. `read()` 시스템 콜 레벨에서 추가 검증: 사용자 공간 버퍼를 `\x00`으로 채워 실제 `vfs_read()`를 호출하지 않고 읽기 차단

### 2. No Write Down (Star Property)
**높은 보안 등급의 사용자가 낮은 보안 등급의 데이터에 쓸 수 없도록 합니다.**

- **정책**: 사용자는 자신의 보안 등급보다 낮은 등급의 파일에 쓸 수 없음
- **예시**: Level 2(Secret) 사용자가 Level 1(Confidential) 파일에 기밀 정보를 복사 → 차단
- **목적**: 고위험 정보가 낮은 보안 등급 파일로 유출되어 권한 없는 사용자에게 노출되는 것 방지
- **구현 방식**:
  1. `open()` 함수에서 write 권한(`O_WRONLY`, `O_RDWR`) 포함 여부 확인
  2. `subject_level > object_level` 조건 위반 시 파일 디스크립터(fd) 자체를 열지 못하게 차단
  3. 이를 통해 `write()` 시스템 콜 호출 전에 선제적으로 차단하여 원본 파일 손상 방지

## 시스템 아키텍처

```
[사용자 공간]
  ├── 일반 애플리케이션 (cat, vim, cp 등)
  │     └── 시스템 콜 발생 (open, read, write)
  │
[커널 공간] ─────────────────────────────────────────────
  │
  ├── 시스템 콜 테이블 (System Call Table)
  │     ├── sys_openat (후킹됨)
  │     ├── sys_read (후킹됨)
  │     └── sys_write (open 단계에서 선제 차단)
  │
  ├── BLP 커널 모듈 (blp_module.ko)
  │     ├── 시스템 콜 후킹 함수 등록
  │     │     ├── hooked_openat: 파일 열기 시 등급 검증
  │     │     │     - write 권한 포함 시 No Write Down 검증
  │     │     │     - 위반 시 fd 생성 차단
  │     │     └── hooked_read: 읽기 시도 시 No Read Up 검증
  │     │           - 위반 시 버퍼를 \x00으로 채워 vfs_read 우회
  │     │
  │     ├── 보안 등급 저장소
  │     │     ├── 사용자 등급: UID → Level 매핑 테이블
  │     │     └── 파일 등급: 파일명/경로 기반 등급 관리
  │     │
  │     ├── BLP 정책 검증 로직
  │     │     ├── No Read Up: subject_level < object_level → 차단
  │     │     ├── No Write Down: subject_level > object_level → 차단
  │     │     └── 정책 위반 시 시스템 콜 실패 반환
  │     │
  │     └── 로깅: printk → /var/log/kern.log
  │           - read() 시스템 콜 실패 기록
  │           - 접근 시도 사용자, 파일명, 위반 내역 저장
  │
  └── VFS Layer (Virtual File System)
        └── vfs_read, vfs_write (BLP 모듈이 선제 차단 시 호출 안 됨)
```

## 보안 위협 시나리오

### 배경
주식회사 "파란 독수리"는 민간 방산기업으로, 최근 국가 중요시설로 지정되면서 보안 시스템을 개편했습니다. 보안 담당자는 강제적 접근통제(MAC) 정책을 기반으로 서버 접근 권한을 할당하기로 결정했습니다.

### 공격 시나리오
한편, 적대 국가의 경쟁 기업 "빨간 호랑이"는 "파란 독수리"의 중요 정보를 탈취하려는 음모를 꾸밉니다. "파란 독수리"의 경력직 엔지니어 A씨는 "빨간 호랑이"로부터 특채 입사 제안을 받으며, 회사의 중요 정보를 유출하면 고액의 금액과 더 높은 직급을 제공한다는 현혹에 넘어갑니다.

A씨는 회사의 중요 정보들이 '공용 파일 저장소'에 저장되어 관리된다는 것을 알고 있었기에, 사내 정보망에 접속하여 중요한 회사 비밀인 '장비 설계도(Level 2: Secret)'를 유출하고자 합니다.

### BLP 모듈에 의한 차단
A씨는 디렉토리에 접근하는 데 성공하지만, 파일을 자신의 이동식 저장소(Level 0 또는 Level 1로 분류)에 복사-붙여넣기 하려는 순간, **"No Write Down" 정책**에 위배되어 저장소 접근에 실패합니다.

- A씨의 보안 등급: Level 2 (Secret)
- 대상 파일 (이동식 저장소): Level 0 또는 Level 1
- 위반 정책: `subject_level (2) > object_level (0 or 1)` → Write 차단

### 결과
실패와 동시에 이 사실은 시스템 로그(`/var/log/kern.log`)에 기록되고 보안 담당 관리자에게 보고되었으며, 결국 A씨는 산업 스파이라는 것이 밝혀집니다.

## 기술 스택

- **C + Linux Kernel API** — 커널 모듈 개발, 시스템 콜 테이블 조작, 후킹 함수 구현
- **System Call Hooking** — `sys_openat`, `sys_read`, `sys_write` 시스템 콜 후킹으로 접근 제어
- **Kernel Debugging** — printk 호출 빈도 최적화, 커널 디버깅 환경 구축으로 안정성 확보
- **VFS (Virtual File System)** — `vfs_read()` 함수 우회 기법으로 읽기 차단 시 시스템 안정성 유지
- **File Descriptor Management** — open 단계에서 write 권한 검증하여 fd 생성 차단

## 담당 업무

6명으로 구성된 팀에서 **개발팀(2명)**, **R&D팀(2명)**, **PM팀(2명)**으로 역할을 분담하여 프로젝트를 진행했습니다. LaTeX를 사용한 보고서 및 회의록 작성으로 전문성과 통일성을 확보했습니다.

**팀 구성:**
- **개발팀**: 이장군, 정재빈 - 프로젝트 개발, 코딩
- **R&D팀**: 유영찬, 이용위 - 정책 연구, 시나리오 구상
- **PM팀**: 고웅빈, 김서현 - 프로젝트 문서 및 보고서 작성, 발표 자료 제작 및 발표

## 프로젝트를 진행하며 발생했던 문제들과 해결과정

### 1. open 시 filename 접근 시 OS 비정상 종료
**문제**: 파일 이름이나 fd(File Descriptor) 등으로 특정 파일에 대한 권한을 설정하는 것은 가능하나, 후킹된 함수에서 이에 대한 정보를 받을 수가 없었습니다. 원인은 알 수 없으나 `open`에서 인자로 받은 `filename`에 접근하는 순간 OS가 비정상 종료되는 현상이 발생했습니다.<br>
**해결**: 여러 부분에 얽혀 있는 `read` 시스템콜을 완전히 차단해버리면 시스템이 터지거나 불안정해지는 경우가 많아, **`count`에 저장된 읽을 바이트 수만큼 사용자 공간의 버퍼에 `\x00`으로 채운 뒤, `regs->ax`를 `count` 값으로 설정**하여, 실제로는 `vfs_read` 함수를 호출하지 않고 사용자가 요청한 크기만큼 데이터를 읽은 것처럼 시스템을 속임으로써 해결했습니다. 이를 통해 read를 차단하면서도 시스템 안정성을 유지할 수 있었습니다.

### 2. sys_openat 후킹 시 OS 비정상 종료
**문제**: `sys_openat`이라는 시스템콜에 후킹을 했는데, open이나 read 등 다른 syscall의 경우 system에서 사용하는 빈도가 높아 후킹을 건 것만으로 OS가 비정상 종료되는 현상이 발생했습니다.<br>
**해결**: **printk 호출이 너무 잦아 발생했던 문제**로 확인되었습니다. printk는 커널 로그를 출력하는 함수인데, 시스템 콜 후킹 시 매번 호출되면 커널 버퍼가 넘치거나 성능 저하가 발생할 수 있습니다. **커널 디버깅 환경을 구축**하여 printk 호출 빈도를 최적화하고, 중요한 이벤트(BLP 정책 위반)만 로깅하도록 수정하여 해결했습니다.

### 3. write 직접 후킹 시 원본 파일 값 삭제
**문제**: `write` 구현 시 write에 직접적으로 후킹하는 경우, write를 비정상 종료했을 때 **원본 파일의 값이 모두 지워지는 문제**가 있었습니다. write 시스템콜을 차단하는 과정에서 파일 시스템 상태가 일관되지 않게 되어 데이터 손실이 발생한 것으로 추정됩니다.<br>
**해결**: write에 직접 후킹하는 대신, **`open()` 함수가 write 권한을 포함하여 호출되는 경우를 확인하여 fd 자체를 열지 못하게 하는 방식**으로 write에 대한 접근제어를 구현했습니다. 즉, `open()` 시스템콜 후킹 단계에서 플래그를 검사하여 `O_WRONLY` 또는 `O_RDWR` 플래그가 포함되어 있고 BLP 정책을 위반하면, 파일 디스크립터 생성 자체를 차단하여 이후 write 시스템콜이 호출되지 않도록 했습니다. 이를 통해 원본 파일 손상을 방지하면서도 write 접근제어를 구현할 수 있었습니다.
