---
layout: project
title: "접근통제 정책 집행을 위한 리눅스 커널 모듈 개발"
summary: "Bell-LaPadula(BLP) 모델을 Kprobe 기반으로 구현한 강제 접근통제(MAC) 커널 모듈입니다. 'No Read Up, No Write Down' 정책을 커널 레벨에서 강제하여 방산기업 등 민감한 정보를 다루는 환경에서 내부자 위협을 차단합니다. 가상의 시나리오를 통해 4단계 보안 등급을 검증합니다."
image: assets/images/s3scan.png
technologies: [C, Linux Kernel, Kprobe, Hashtable, BLP Model]
github:
categories: security
---

## 프로젝트 배경

민간 방산기업과 같이 국가 중요시설로 지정된 조직에서는 DAC(Discretionary Access Control)만으로 기밀 정보를 보호하기 어렵습니다. 내부자가 권한을 남용하거나 산업 스파이가 침투할 경우, 중요 설계도나 기밀 문서가 유출될 위험이 있습니다.

Bell-LaPadula(BLP) 모델은 **"No Read Up(상위 등급 읽기 금지), No Write Down(하위 등급 쓰기 금지)"** 원칙으로 기밀성을 보장하는 대표적인 MAC(Mandatory Access Control) 모델입니다. 이를 리눅스 커널의 Kprobe 기반 함수 후킹으로 구현하여, 사용자가 파일 접근 시도 시 커널 레벨에서 보안 등급을 강제 검증하도록 했습니다.

## 주요 기능

### 1. Kprobe 기반 커널 레벨 접근 제어
Kprobe를 사용하여 파일 열기와 파일 읽기 동작을 커널 레벨에서 가로챕니다. 파일 접근 시도마다 사용자와 파일의 보안 등급을 조회하여 BLP 정책을 실시간으로 검증합니다.

### 2. 4단계 보안 등급 체계
방산기업의 기밀성 요구사항에 맞춰 다음의 보안 등급을 정의합니다:
- **Level 0 (Unclassified)**: 공개 정보
- **Level 1 (Confidential)**: 사내 기밀
- **Level 2 (Secret)**: 중요 기밀 (장비 설계도 등)
- **Level 3 (Top Secret)**: 최고 기밀

### 3. "No Read Up" 정책 구현
낮은 보안 등급의 사용자가 높은 보안 등급의 파일을 읽으려 할 때, 커널 레벨에서 이를 감지하고 차단합니다. 읽기 동작을 직접 차단하면 시스템이 불안정해지므로, 사용자 공간 버퍼를 빈 데이터로 채워 실제 파일 내용이 전달되지 않도록 하면서도 시스템 안정성을 유지하는 방식으로 구현했습니다.

### 4. "No Write Down" 정책 구현
높은 보안 등급의 사용자가 낮은 보안 등급의 파일에 쓰기를 시도할 때, 파일 열기 단계에서 쓰기 권한 포함 여부를 검사합니다. 정책 위반 시 파일 열기 자체를 차단하여, 쓰기 동작이 실행되기 전에 선제적으로 접근을 막습니다. 이를 통해 기밀 정보가 낮은 등급 파일로 유출되는 것을 방지합니다.

### 5. 해시테이블 기반 보안 등급 관리
커널 해시테이블을 사용하여 사용자와 파일의 보안 등급을 메모리에 저장합니다. 모듈 로드 시 규칙 파일에서 등급 정보를 읽어와 등록하며, O(1) 시간 복잡도로 빠른 등급 조회가 가능합니다.

### 6. Python 관리 유틸리티
보안 등급 규칙을 간편하게 추가할 수 있는 Python CLI 도구를 제공합니다. 파일명이나 사용자에게 보안 레벨(1~4)을 부여하면 규칙 파일에 자동으로 저장됩니다.

### 7. 시스템 로그 기반 감사
보안 정책 위반 시도를 커널 로그에 기록하여 침해사고 분석과 내부자 위협 추적을 지원합니다. 접근을 시도한 사용자, 대상 파일, 보안 등급, 접근 결과가 모두 기록됩니다.

## BLP 모델 동작 원리

BLP 모델의 2대 핵심 속성을 Kprobe 후킹으로 구현합니다:

### 1. No Read Up (Simple Security Property)
**낮은 보안 등급의 사용자가 높은 보안 등급의 데이터를 읽을 수 없도록 합니다.**

<img src="{{ site.baseurl }}/assets/images/read module.png" alt="Read Module 동작 원리" width="100%">

- **정책**: 사용자는 자신의 보안 등급보다 높은 등급의 파일을 읽을 수 없음
- **예시**: Level 1(Confidential) 엔지니어가 Level 2(Secret) 장비 설계도 파일을 `cat` 시도 → 차단
- **구현 방식 (read_hook.c)**: 
  1. `vfs_read` 후킹으로 파일 읽기 시도 감지
  2. `dentry_path_raw()`로 절대 경로 획득
  3. 해시테이블에서 사용자 UID와 파일 경로의 보안 등급 조회
  4. `cur_user_level < cur_doc_level` 조건 위반 시:
     - `copy_to_user(buf, "\x00", count)`로 버퍼를 0으로 채움
     - `regs->ax = count`로 읽은 바이트 수 설정
     - 실제 `vfs_read()`는 호출되지 않음 (시스템 안정성 유지)

### 2. No Write Down (Star Property)
**높은 보안 등급의 사용자가 낮은 보안 등급의 데이터에 쓸 수 없도록 합니다.**

<img src="{{ site.baseurl }}/assets/images/open module.png" alt="Open Module 동작 원리" width="100%">

- **정책**: 사용자는 자신의 보안 등급보다 낮은 등급의 파일에 쓸 수 없음
- **예시**: Level 2(Secret) 사용자가 Level 1(Confidential) 파일에 기밀 정보를 복사 → 차단
- **목적**: 고위험 정보가 낮은 보안 등급 파일로 유출되어 권한 없는 사용자에게 노출되는 것 방지
- **구현 방식 (open_hook.c)**:
  1. `do_filp_open` 후킹으로 파일 열기 시도 감지
  2. `open_flags` 구조체에서 `open_flag` 확인
  3. `op->open_flag & (O_WRONLY | O_RDWR)` 로 write 권한 검사
  4. `cur_user_level > cur_doc_level` 조건 위반 시 `-EACCES` 반환
  5. fd 생성 자체가 차단되어 이후 `write()` 시스템 콜이 호출되지 않음


## 보안 위협 시나리오

### 배경
주식회사 "파란 독수리"는 민간 방산기업으로, 최근 국가 중요시설로 지정되면서 보안 시스템을 개편했습니다. 보안 담당자는 강제적 접근통제(MAC) 정책을 기반으로 서버 접근 권한을 할당하기로 결정했습니다.

### 공격 시나리오
한편, 적대 국가의 경쟁 기업 "빨간 호랑이"는 "파란 독수리"의 중요 정보를 탈취하려는 음모를 꾸밉니다. "파란 독수리"의 경력직 엔지니어 A씨는 "빨간 호랑이"로부터 특채 입사 제안을 받으며, 회사의 중요 정보를 유출하면 고액의 금액과 더 높은 직급을 제공한다는 현혹에 넘어갑니다.

A씨는 회사의 중요 정보들이 '공용 파일 저장소'에 저장되어 관리된다는 것을 알고 있었기에, 사내 정보망에 접속하여 중요한 회사 비밀인 '장비 설계도(Level 2: Secret)'를 유출하고자 합니다.

### BLP 모듈에 의한 차단
A씨는 디렉토리에 접근하는 데 성공하지만, 파일을 자신의 이동식 저장소(Level 0 또는 Level 1로 분류)에 복사-붙여넣기 하려는 순간, **"No Write Down" 정책**에 위배되어 저장소 접근에 실패합니다.

- A씨의 보안 등급: Level 2 (Secret)
- 대상 파일 (이동식 저장소): Level 0 또는 Level 1
- 위반 정책: `cur_user_level (2) > cur_doc_level (0 or 1)` → Write 차단
- 실제 동작: `do_filp_open` 후킹에서 `-EACCES` 반환, fd 생성 실패

### 결과
실패와 동시에 이 사실은 시스템 로그(`/var/log/kern.log`)에 기록되고 보안 담당 관리자에게 보고되었으며, 결국 A씨는 산업 스파이라는 것이 밝혀집니다.

## 기술 스택

- **C + Linux Kernel API** — 커널 모듈 개발, pt_regs 레지스터 조작, pre_handler 구현
- **Kprobe Framework** — `do_filp_open`, `vfs_read` 함수 동적 후킹, 런타임 접근 제어
- **Hashtable** — `DEFINE_HASHTABLE` 매크로로 보안 등급 관리, O(1) UID/파일경로 조회
- **VFS Internals** — `dentry_path_raw()` 절대 경로 추출, `open_flags` 구조체 분석
- **User-Kernel Communication** — `copy_to_user()`로 버퍼 조작, `regs->ax` 레지스터 값 설정
- **Kernel Debugging** — printk 로그 최적화, 커널 디버깅 환경 구축으로 안정성 확보
- **Python File I/O** — add.py로 /home/lee/rule 파일 기반 규칙 관리

## 담당 업무

6명으로 구성된 팀에서 **개발팀(2명)**, **R&D팀(2명)**, **PM팀(2명)**으로 역할을 분담하여 프로젝트를 진행했습니다. LaTeX를 사용한 보고서 및 회의록 작성으로 전문성과 통일성을 확보했습니다.

**팀 구성:**
- **개발팀**
  - Kprobe 후킹 모듈 개발 (`open_hook.c`, `read_hook.c`)
  - 해시테이블 기반 보안 등급 저장 및 조회 로직 구현
  - `dentry_path_raw()` 절대 경로 추출 및 `pt_regs` 레지스터 인자 파싱
  - `copy_to_user()` 버퍼 조작 및 `regs->ax` 레지스터 값 설정
  - Python 규칙 관리 유틸리티 (`add.py`) 개발
  
- **R&D팀**
  - BLP 모델 정책 연구 및 리눅스 커널 적용 방안 분석
  - 방산 기업 보안 위협 시나리오 구상
  - Kprobe 프레임워크 기술 조사 및 시스템 콜 후킹 대안 검토

- **PM팀**
  - LaTeX 기반 캡스톤 최종 보고서 작성
  - 프로젝트 발표 자료 제작 및 발표
  - 회의록 작성 및 일정 관리

저는 R&D팀 팀장으로서 **접근통제 정책 연구**, **보안 위협 시나리오 설계**, **개발팀 기술 지원**, **프로젝트 관리**를 담당했습니다.

### 1. 접근통제 정책 연구 및 분석

BLP 모델을 리눅스 커널에 적용하기 위한 이론적 토대를 마련하는 역할을 맡았습니다. 접근통제 정책의 세 가지 유형(MAC, DAC, RBAC)을 비교 분석하고, 방산기업 환경에 적합한 강제적 접근통제(MAC) 방식을 선정하는 근거를 제시했습니다.

- BLP(Bell-LaPadula) 모델의 핵심 속성인 **No Read Up(단순 보안 규칙)**과 **No Write Down(특성 규칙)**을 분석하고, 이를 커널 레벨에서 구현하기 위한 방안을 설계했습니다. 기밀성 유지에는 강하지만 무결성 문제가 발생할 수 있다는 BLP 모델의 한계도 함께 팀원들에게 공유했습니다.
- MLS(다중등급보안) 정책을 연구하여 **4단계 보안 등급 체계(Unclassified → Confidential → Secret → Top Secret)**를 정의했습니다. 각 등급별 접근 규칙을 명세화하여 개발팀이 해시테이블에 저장할 보안 등급 구조의 기초를 제공했습니다.
- 보안 OS 개념과 LSM(Linux Security Modules) 프레임워크를 조사하여, SELinux·AppArmor 등 기존 보안 모듈과의 차이점을 정리했습니다. 이를 통해 프로젝트가 기존 보안 프레임워크와 어떤 차별점을 가지는지 명확히 했습니다.
- "리눅스 운영체제를 위한 보안 시스템 설계" 논문을 요약하여 팀원 대상으로 발표했으며, 팀원 이용위가 담당한 "안전한 임베디드 시스템을 위한 E-BLP 보안 모델의 구현" 논문의 분석을 보조하고 내용을 정리했습니다. BLP 모델의 최신 기술동향과 개선방법을 지속적으로 조사하여 팀 내에 공유했습니다.

### 2. 보안 위협 시나리오 및 보안 정책 설계

프로젝트 초기 교수님(김준섭 교수님)·멘토님(강정민 박사님)과의 회의에서 "시나리오를 최우선으로 구상하고, 그에 따른 보안 정책을 수립한 뒤, 정책 기반으로 개발을 시작하라"는 방향성을 받아 R&D팀이 주도하여 시나리오와 정책을 설계했습니다.

- 방산기업("파란 독수리")을 배경으로 한 **내부자 위협 시나리오**의 초안을 작성하고, 팀원 이용위와 디스코드를 통해 지속적으로 내용을 보완해 나갔습니다. 경력직 엔지니어가 적대 기업("빨간 호랑이")의 유혹에 넘어가 기밀 정보를 유출하려는 구체적인 공격 행위를 시나리오에 포함시켰습니다.
- 교수님의 피드백("구체적인 공격 행위를 포함하면 방어를 위한 보안 정책을 더 구체적으로 설계할 수 있을 것", "보안 정책의 정보 등급에 구체적 예시를 포함하면 좋겠다")을 반영하여, 등급별 보호 대상 파일(장비 설계도, 사내 기밀 등)과 구체적 접근 규칙을 명세화했습니다.
- 완성된 보안 위협 시나리오와 보안 정책은 개발팀이 Kprobe 후킹 모듈의 BLP 검증 로직(`cur_user_level` vs `cur_doc_level` 비교)을 구현하는 데 직접적인 기반이 되었습니다.

### 3. 개발팀 기술 지원

개발팀이 Kprobe 후킹 구현 중 난관에 부딪혔을 때, R&D팀에서 관련 기술을 조사하여 해결 방안을 모색하는 역할을 수행했습니다.

- 2024년 5월 15일 비정기 프로젝트 회의에서 개발팀이 시스템 콜 후킹 과정에서 커널 패닉 문제를 겪고 있다는 보고를 받고, 관련 기술인 **SELinux의 강제적 접근통제 메커니즘**을 조사했습니다. 조사한 내용을 분석·요약하여 정기 회의에서 팀원들에게 브리핑하고, 팀원 이용위에게는 SELinux의 강제적 통제 모듈 중 시스템 콜 후킹 관련 부분을 추가 조사하도록 업무를 할당했습니다.
- 개발팀이 문제를 자체적으로 해결한 이후에도, 완성된 커널 모듈이 설계한 보안 정책과 시나리오에 부합하는지 검증하는 작업을 지원했습니다. 시나리오 기반으로 테스트 케이스(No Read Up 위반, No Write Down 위반, root 예외 처리 등)를 제시하여 정책 검증을 수행했습니다.

### 4. 프로젝트 관리 및 발표자료 제작

R&D팀 팀장으로서 PM팀과 협업하여 프로젝트 전체 일정을 조율하고, 매주 정기 회의를 주도하며, 최종 발표자료를 함께 제작했습니다. PM팀은 프로젝트 문서 작성과 발표 자료 제작이 처음이었기 때문에, 보고서 구조 잡기부터 LaTeX 작성법, 발표 흐름 구성까지 함께 논의하며 지원했습니다.

- **매주 일요일 22시** 정기 프로젝트 회의(디스코드, 1시간 내외)를 주도하며, 각 팀(개발팀·R&D팀·PM팀)의 진행 상황을 점검하고 다음 주 업무를 할당했습니다. 필요 시 비정기 회의도 개최하여 긴급 이슈에 대응했습니다.
- 전체 프로젝트 회의(담당 교수님, 멘토님 참석)에서 R&D팀 연구 결과물을 발표하고, 피드백을 반영하여 최종 완성도를 높였습니다. 이후 최종 발표 기한까지 R&D팀이 **발표자료 제작을 주도**하며, 프로젝트 인원 모두에게 수시로 피드백을 받아 수정·개선했습니다.
- PM팀이 최종 보고서를 작성할 때, 보고서의 전체 목차와 논리 흐름을 함께 설계하고, 작성된 초안을 직접 첨삭하며 내용의 정확성과 일관성을 검수했습니다. R&D팀이 발표자료에서 제작한 시스템 아키텍처 도식, BLP 정책 도표 등의 자료를 PM팀에 공유하여 보고서에 활용할 수 있도록 했습니다. LaTeX 문법이나 문서 스타일에 대해서도 PM팀과 수시로 소통하며, 보고서의 전문성과 통일성을 함께 만들어 나갔습니다.

### 5. 향후 연구 방향 제시: AI(LLM) 접근 통제

보안 위협 시나리오와 정책 완성 이후, 멘토님이 심화 연구 주제로 "AI(LLM)에 대한 접근 통제"를 제시했습니다. 이를 약 6주간(5/6~6/10) 연구하여 최종 발표에 '향후 연구' 섹션으로 포함시켰습니다.

<img src="{{ site.baseurl }}/assets/images/AI control.jpg" alt="AI 접근 통제 모델" width="100%">

- 적대적 프롬프팅(Adversarial Prompting) 관련 자료 및 AI 보안 논문 5건 이상을 조사·분석했습니다. "From ChatGPT to ThreatGPT: Impact of Generative AI in Cybersecurity and Privacy"(arXiv:2307.00691) 등의 논문을 팀원에게 일부 요약하도록 지시하고, 분석 결과를 종합하여 연구 방향을 설정했습니다.
- 연구 결과물 3가지를 완성했습니다: **AI 접근 통제 모델**, **AI 접근 통제 정책**, **AI 접근 통제 워크플로우**(작업 흐름 도식). 각 결과물은 교수님·멘토님과 카카오톡 및 줌을 통해 수시로 피드백을 주고받으며 완성도를 높였으며, 해당 분야(인공지능)를 연구하는 교수님에게도 별도로 자문을 구했습니다.
- 팀원에게 완성된 AI 접근통제 정책을 시각화하는 도식 자료를 제작하도록 지시하고, 실시간으로 피드백을 제공하며 수정해 나갔습니다. 완성된 결과물은 최종 팀 보고서 및 발표 자료에 포함되었습니다.
  

## 프로젝트를 진행하며 발생했던 문제들과 해결과정

### 1. do_filp_open 후킹 시 filename 접근 시 OS 비정상 종료
**문제**: 파일 이름이나 fd(File Descriptor) 등으로 특정 파일에 대한 권한을 설정하는 것은 가능하나, Kprobe pre_handler에서 `do_filp_open`의 `filename` 인자에 접근하는 순간 OS가 비정상 종료되는 현상이 발생했습니다. 원인은 정확히 파악되지 않았으나, Kprobe 컨텍스트에서 일부 커널 데이터 구조체 접근이 불안정했던 것으로 추정됩니다.<br>
**해결**: 파일명 접근 방식을 `pt_regs`에서 직접 추출하는 대신, **해시테이블에 파일 절대 경로를 미리 저장**하고, 후킹 시점에 해시테이블에서 조회하는 방식으로 변경했습니다. UID는 `current_uid()`로 안정적으로 획득할 수 있었으며, 파일 경로는 `vfs_read` 후킹에서 `dentry_path_raw()`을 사용하여 안전하게 추출할 수 있었습니다.

### 2. printk 과다 호출로 인한 시스템 불안정
**문제**: `vfs_read`는 시스템에서 사용하는 빈도가 매우 높아, 후킹 시 매번 printk를 호출하면 커널 로그 버퍼가 넘치고 시스템 전체 성능이 저하되어 OS가 비정상 종료되는 현상이 발생했습니다.<br>
**해결**: **printk 호출 빈도를 최적화**하여, BLP 정책 위반 시에만 로그를 기록하도록 수정했습니다. 정상적인 파일 접근(정책 통과)은 로깅하지 않고, 차단 이벤트(No Read Up / No Write Down 위반)만 `/var/log/kern.log`에 기록하여 시스템 안정성을 유지했습니다. 또한 커널 디버깅 환경을 구축하여 로그 레벨을 조정하고 필수 정보(UID, 파일경로, 보안 등급)만 출력하도록 했습니다.

### 3. vfs_read 직접 차단 시 시스템 불안정 / write 직접 후킹 시 원본 파일 삭제
**문제**: 
- 초기에는 `vfs_read()`를 직접 차단(`return -EACCES`)하거나 호출하지 않으려 했으나, 여러 부분에 얽혀 있는 read 경로를 완전히 차단하면 시스템이 불안정해지는 현상이 발생했습니다.
- `write` 시스템콜을 직접 후킹하여 차단하는 경우, 차단 시점에 따라 **원본 파일의 값이 모두 지워지는 문제**가 발생했습니다. write 작업 중간에 차단되면 파일 시스템 상태가 일관되지 않게 되어 데이터 손실이 발생한 것으로 추정됩니다.

**해결**:
- **Read 차단**: `vfs_read()` 함수를 실제로 호출하지 않고, **`copy_to_user(buf, "\x00", count)`로 사용자 공간 버퍼를 0으로 채운 뒤, `regs->ax = count` 설정**하여 사용자가 요청한 크기만큼 데이터를 읽은 것처럼 시스템을 속였습니다. 이를 통해 read를 차단하면서도 시스템 안정성을 유지할 수 있었습니다.
- **Write 차단**: write에 직접 후킹하는 대신, **`do_filp_open()` 후킹 단계에서 `open_flags` 구조체의 `open_flag & (O_WRONLY | O_RDWR)` 조건을 검사**하여, BLP 정책을 위반하면 파일 디스크립터 생성 자체를 `-EACCES`로 차단했습니다. 이를 통해 이후 write 시스템콜이 호출되지 않도록 하여 원본 파일 손상을 방지하면서도 write 접근제어를 구현할 수 있었습니다.
